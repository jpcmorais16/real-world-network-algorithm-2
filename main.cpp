#include <iostream>
#include <vector>
#include <unordered_set>
#include <random>
#include <numeric>
#include <chrono>
#include <cmath>
#include <unordered_map>
#include <fstream>
#include <string>
#include <iomanip>
#include <ctime>
#include <sstream>
#include <algorithm>
#include "networkMetrics.h"

using namespace std;

std::random_device rd;
std::mt19937 gen(rd());

bool eventOccurs(double p) {
    std::uniform_real_distribution<> dis(0.0, 1.0);
    return dis(gen) < p;
}

int get_random_integer(int min, int max) {
    std::uniform_int_distribution<> distr(min, max);
    return distr(gen);
}

std::string get_brazil_time() {
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    
    // Brazil is UTC-3 (BRT - Bras√≠lia Time)
    // Convert to Brazil time by subtracting 3 hours
    auto brazil_time = std::chrono::system_clock::from_time_t(time_t) - std::chrono::hours(3);
    time_t = std::chrono::system_clock::to_time_t(brazil_time);
    
    std::tm* timeinfo = std::gmtime(&time_t);
    std::stringstream ss;
    ss << std::put_time(timeinfo, "%Y-%m-%d %H:%M:%S BRT");
    return ss.str();
}

std::unordered_map<double, std::vector<double>> p_cache;

double P(double p, int x) {
    if (p == 0.0) {
        return 0.1;
    }
    double denominator = 1.0 - pow(1.0 - p, 10);
    return (p * pow(1.0 - p, x - 1)) / denominator;
}

int get_number_of_steps(double p) {
    if (p_cache.find(p) == p_cache.end()) {
        std::vector<double> weights;
        for (int x = 1; x <= 10; ++x) {
            weights.push_back(P(p, x));
        }
        p_cache[p] = weights;
    }

    std::discrete_distribution<> dist(p_cache[p].begin(), p_cache[p].end());
    return dist(gen) + 1;
}

int random_walk(const std::vector<std::unordered_set<int>>& graph, int start, int number_of_steps) {
    int current_index = start;

    for (int i = 0; i < number_of_steps; i++) {
        const auto& current = graph[current_index];
        if (current.empty()) {
            break;
        }
        
        std::vector<int> neighbors(current.begin(), current.end());
        int set_index = get_random_integer(0, neighbors.size() - 1);
        current_index = neighbors[set_index];
    }

    return current_index;
}

std::vector<std::unordered_set<int>> generate_network(int N, double m, double p, double fp) {
    std::vector<std::unordered_set<int>> graph(10);

    for (int i = 0; i < 10; i++) {
        graph[i].insert((i + 1) % 10);
        if (i > 0) {
            graph[i].insert((i - 1));
        }
    }
    graph[0].insert(9);

    int n_nodes = 10;

    for (int i = 0; i < N; i++) {
        int start = get_random_integer(0, n_nodes - 1);
        int current = start;

        std::vector<int> marked;
        marked.push_back(start);

        // Calculate base number of nodes to mark (integer part of m)
        int base_marked = static_cast<int>(m);
        
        // Mark the base number of nodes
        for (int j = 0; j < base_marked - 1; j++) {
            int number_of_steps = get_number_of_steps(p);
            current = random_walk(graph, current, number_of_steps);
            marked.push_back(current);
        }
        
        // Add one more node with probability equal to the decimal part of m
        double decimal_part = m - base_marked;
        if (eventOccurs(decimal_part)) {
            int number_of_steps = get_number_of_steps(p);
            current = random_walk(graph, current, number_of_steps);
            marked.push_back(current);
        }

        graph.push_back(std::unordered_set<int>());
        
        for (int val : marked) {
            graph[n_nodes].insert(val);
            graph[val].insert(n_nodes);
        }
        
        for (size_t i = 0; i < marked.size(); i++) {
            for (size_t j = i + 1; j < marked.size(); j++) {
                if (marked[i] != marked[j] && eventOccurs(fp)) {
                    graph[marked[i]].insert(marked[j]);
                    graph[marked[j]].insert(marked[i]);
                }
            }
        }

        n_nodes++;
    }

    std::cout << "Network generated successfully\n";

    return graph;
}

void save_network_to_file(const std::vector<std::unordered_set<int>>& graph, const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open file " << filename << " for writing" << std::endl;
        return;
    }
    
    // Write header with network parameters
    file << "# Network generated by C++ algorithm" << std::endl;
    file << "# Format: source target" << std::endl;
    file << "# Each line represents an undirected edge" << std::endl;
    file << std::endl;
    
    // Write edges (avoid duplicates since it's an undirected graph)
    for (size_t i = 0; i < graph.size(); ++i) {
        for (int neighbor : graph[i]) {
            // Only write edge if source < target to avoid duplicates
            if (i < static_cast<size_t>(neighbor)) {
                file << i << " " << neighbor << std::endl;
            }
        }
    }
    
    file.close();
    std::cout << "Network saved to " << filename << std::endl;
}

std::vector<std::unordered_set<int>> generate_network_with_save(int N, double m, double p, double fp, const std::string& filename) {
    auto graph = generate_network(N, m, p, fp);
    
    // Save to file if filename is provided
    if (!filename.empty()) {
        save_network_to_file(graph, filename);
    }
    
    return graph;
}

struct SimulationResult {
    double avgClust;
    double transitivity;
    double avgPathLength;
    double pearsonR;
    double powerLawCoefficient;
    double powerLawCumulativeCoefficient;
    double pearsonRCumulative;
    double maxDegree;
    double constructionTime;
    double pathCalcTime;
    double totalTime;
    size_t numThreads;
};

SimulationResult run_simulation(int N, double p, double m, double friendship_probability) {
    SimulationResult result;
    
    auto start_time = std::chrono::high_resolution_clock::now();
    
    auto graph = generate_network(N, m, p, friendship_probability);
    
    auto end_time = std::chrono::high_resolution_clock::now();
    result.constructionTime = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count() / 1000.0;
    
    auto metrics = calculateAllMetrics(graph);
    
    result.avgClust = metrics.clusteringCoefficient;
    result.transitivity = metrics.clusteringCoefficient;
    result.avgPathLength = metrics.avgPathLength;
    result.pearsonR = metrics.pearsonR;
    result.powerLawCoefficient = metrics.powerLawCoefficient;
    result.powerLawCumulativeCoefficient = metrics.powerLawCumulativeCoefficient;
    result.pearsonRCumulative = metrics.pearsonRCumulative;
    result.maxDegree = metrics.maxDegree;
    result.pathCalcTime = metrics.avgPathLengthDuration.count() / 1000.0;
    result.totalTime = result.constructionTime + result.pathCalcTime;
    result.numThreads = metrics.numThreads;
    
    std::cout << "Simulation completed - Clustering: " << result.avgClust 
              << ", Path length: " << result.avgPathLength 
              << ", Construction time: " << result.constructionTime << "s"
              << ", Path calc time: " << result.pathCalcTime << "s"
              << ", Total time: " << result.totalTime << "s"
              << ", Threads: " << metrics.numThreads << "\n";
              
    return result;
}

double calculate_std_dev(const std::vector<double>& values, double mean) {
    double variance = 0.0;
    for (double value : values) {
        double diff = value - mean;
        variance += diff * diff;
    }
    return std::sqrt(variance / values.size());
}

void create_point_sequential(const std::string& filepath, int N, double p, double m, double friendship_probability, int n_simulations) {
    std::cout << "Running " << n_simulations << " sequential simulations...\n";
    
    std::vector<SimulationResult> results;
    
    std::ofstream partial_file("partial.txt", std::ios_base::app);
    if (!partial_file.is_open()) {
        std::cerr << "Warning: Could not open partial.txt for writing individual results" << std::endl;
    } else {
        partial_file.seekp(0, std::ios::end);
        if (partial_file.tellp() == 0) {
            partial_file << "Simulation\tN\tp\tm\tfriendship_probability\tavg_clustering\ttransitivity\tavg_path\tr\tslope\tslope_cumulative\tr_cumulative\tmax_degree\tconstruction_time\tpath_calc_time\ttotal_time\tthreads\n";
        }
        partial_file << std::fixed << std::setprecision(4);
    }
    
    for (int i = 0; i < n_simulations; i++) {
        std::cout << get_brazil_time() << " Simulation " << (i+1) << "/" << n_simulations << "...\n";
        SimulationResult result = run_simulation(N, p, m, friendship_probability);
        results.push_back(result);
        
        if (partial_file.is_open()) {
            partial_file << (i+1) << "\t" 
                         << N << "\t" 
                         << p << "\t" 
                         << m << "\t" 
                         << friendship_probability << "\t"
                         << result.avgClust << "\t"
                         << result.transitivity << "\t"
                         << result.avgPathLength << "\t"
                         << result.pearsonR << "\t"
                         << result.powerLawCoefficient << "\t"
                         << result.powerLawCumulativeCoefficient << "\t"
                         << result.pearsonRCumulative << "\t"
                         << result.maxDegree << "\t"
                         << result.constructionTime << "\t"
                         << result.pathCalcTime << "\t"
                         << result.totalTime << "\t"
                         << result.numThreads << "\n";
        }
    }
    
    if (partial_file.is_open()) {
        partial_file.close();
        std::cout << "Individual simulation results written to partial.txt" << std::endl;
    }
    
    // Calculate averages
    double avg_clust = 0.0, avg_trans = 0.0, avg_path = 0.0, avg_r = 0.0;
    double avg_slope = 0.0, avg_slope_cumulative = 0.0, avg_r_cumulative = 0.0;
    double avg_max_degree = 0.0, avg_construction_time = 0.0;
    double avg_shortest_path_calculation_time = 0.0;
    double avg_total_time = 0.0;
    
    std::vector<double> clust_values, trans_values, path_values, r_values;
    std::vector<double> slope_values, slope_cumulative_values, r_cumulative_values;
    std::vector<double> max_degree_values, construction_time_values, path_calc_time_values;
    std::vector<double> total_time_values;
    
    for (const auto& r : results) {
        avg_clust += r.avgClust;
        avg_trans += r.transitivity;
        avg_path += r.avgPathLength;
        avg_r += r.pearsonR;
        avg_slope += r.powerLawCoefficient;
        avg_slope_cumulative += r.powerLawCumulativeCoefficient;
        avg_r_cumulative += r.pearsonRCumulative;
        avg_max_degree += r.maxDegree;
        avg_construction_time += r.constructionTime;
        avg_shortest_path_calculation_time += r.pathCalcTime;
        avg_total_time += r.totalTime;
        
        clust_values.push_back(r.avgClust);
        trans_values.push_back(r.transitivity);
        path_values.push_back(r.avgPathLength);
        r_values.push_back(r.pearsonR);
        slope_values.push_back(r.powerLawCoefficient);
        slope_cumulative_values.push_back(r.powerLawCumulativeCoefficient);
        r_cumulative_values.push_back(r.pearsonRCumulative);
        max_degree_values.push_back(r.maxDegree);
        construction_time_values.push_back(r.constructionTime);
        path_calc_time_values.push_back(r.pathCalcTime);
        total_time_values.push_back(r.totalTime);
    }
    
    avg_clust /= n_simulations;
    avg_trans /= n_simulations;
    avg_path /= n_simulations;
    avg_r /= n_simulations;
    avg_slope /= n_simulations;
    avg_slope_cumulative /= n_simulations;
    avg_r_cumulative /= n_simulations;
    avg_max_degree /= n_simulations;
    avg_construction_time /= n_simulations;
    avg_shortest_path_calculation_time /= n_simulations;
    avg_total_time /= n_simulations;
    
    double std_clust = calculate_std_dev(clust_values, avg_clust);
    double std_trans = calculate_std_dev(trans_values, avg_trans);
    double std_path = calculate_std_dev(path_values, avg_path);
    double std_r = calculate_std_dev(r_values, avg_r);
    double std_slope = calculate_std_dev(slope_values, avg_slope);
    double std_slope_cumulative = calculate_std_dev(slope_cumulative_values, avg_slope_cumulative);
    double std_r_cumulative = calculate_std_dev(r_cumulative_values, avg_r_cumulative);
    double std_max_degree = calculate_std_dev(max_degree_values, avg_max_degree);
    double std_construction_time = calculate_std_dev(construction_time_values, avg_construction_time);
    double std_shortest_path_calculation_time = calculate_std_dev(path_calc_time_values, avg_shortest_path_calculation_time);
    double std_total_time = calculate_std_dev(total_time_values, avg_total_time);
    
    std::ofstream file(filepath, std::ios_base::app);
    if (file.is_open()) {
        file << std::fixed << std::setprecision(4);
        file << N << "\t" << p << "\t" << m << "\t" << friendship_probability << "\t"
             << avg_clust << " // " << std_clust << "\t"
             << avg_trans << " // " << std_trans << "\t"
             << avg_path << " // " << std_path << "\t"
             << avg_r << " // " << std_r << "\t"
             << avg_slope << " // " << std_slope << "\t"
             << avg_slope_cumulative << " // " << std_slope_cumulative << "\t"
             << avg_r_cumulative << " // " << std_r_cumulative << "\t"
             << avg_max_degree << " // " << std_max_degree << "\t"
             << avg_construction_time << " // " << std_construction_time << "\t"
             << avg_shortest_path_calculation_time << " // " << std_shortest_path_calculation_time << "\t"
             << avg_total_time << " // " << std_total_time << "\n";
        file.close();
        std::cout << "Results written to " << filepath << std::endl;
    } else {
        std::cerr << "Error: Could not open file " << filepath << std::endl;
    }
}

struct LastCompleted {
    int N;
    double p;
    double m;
    double friendship_probability;
    bool valid;
};

LastCompleted get_last_completed_combination(const std::string& output_file) {
    LastCompleted result;
    result.valid = false;
    
    std::ifstream file(output_file);
    if (!file.is_open()) {
        std::cerr << "Debug: Could not open file: " << output_file << std::endl;
        return result;
    }
    
    std::string line;
    std::string last_valid_line;
    
    // Read all lines and find the last non-empty line
    while (std::getline(file, line)) {
        // Skip empty lines and lines starting with #
        if (!line.empty() && line[0] != '#') {
            // Remove leading/trailing whitespace
            size_t first = line.find_first_not_of(" \t");
            if (first != std::string::npos) {
                size_t last = line.find_last_not_of(" \t");
                if (last != std::string::npos && last >= first) {
                    last_valid_line = line.substr(first, last - first + 1);
                }
            }
        }
    }
    
    file.close();
    
    if (last_valid_line.empty()) {
        std::cerr << "Debug: No valid line found in file" << std::endl;
        return result;
    }
    
    std::cerr << "Debug: Last valid line: " << last_valid_line.substr(0, 50) << "..." << std::endl;
    
    // Parse the line - format is tab-separated: N\tp\tm\tfriendship_probability\t...
    std::istringstream iss(last_valid_line);
    std::string token;
    std::vector<std::string> tokens;
    
    while (std::getline(iss, token, '\t')) {
        // Trim whitespace from token
        size_t first = token.find_first_not_of(" \t");
        if (first != std::string::npos) {
            size_t last = token.find_last_not_of(" \t");
            if (last != std::string::npos && last >= first) {
                std::string trimmed = token.substr(first, last - first + 1);
                if (!trimmed.empty()) {
                    tokens.push_back(trimmed);
                }
            }
        }
    }
    
    std::cerr << "Debug: Found " << tokens.size() << " tokens" << std::endl;
    
    if (tokens.size() < 4) {
        std::cerr << "Debug: Not enough tokens (need 4, found " << tokens.size() << ")" << std::endl;
        return result;
    }
    
    try {
        // Extract numeric values (handle cases where token might contain " // std_dev")
        std::string n_str = tokens[0];
        std::string p_str = tokens[1];
        std::string m_str = tokens[2];
        std::string fp_str = tokens[3];
        
        // Remove any trailing " // ..." if present
        size_t pos = n_str.find(" //");
        if (pos != std::string::npos) n_str = n_str.substr(0, pos);
        pos = p_str.find(" //");
        if (pos != std::string::npos) p_str = p_str.substr(0, pos);
        pos = m_str.find(" //");
        if (pos != std::string::npos) m_str = m_str.substr(0, pos);
        pos = fp_str.find(" //");
        if (pos != std::string::npos) fp_str = fp_str.substr(0, pos);
        
        // Trim again after removing " // ..."
        size_t first = n_str.find_first_not_of(" \t");
        if (first != std::string::npos) {
            size_t last = n_str.find_last_not_of(" \t");
            if (last != std::string::npos && last >= first) {
                n_str = n_str.substr(first, last - first + 1);
            }
        }
        first = p_str.find_first_not_of(" \t");
        if (first != std::string::npos) {
            size_t last = p_str.find_last_not_of(" \t");
            if (last != std::string::npos && last >= first) {
                p_str = p_str.substr(first, last - first + 1);
            }
        }
        first = m_str.find_first_not_of(" \t");
        if (first != std::string::npos) {
            size_t last = m_str.find_last_not_of(" \t");
            if (last != std::string::npos && last >= first) {
                m_str = m_str.substr(first, last - first + 1);
            }
        }
        first = fp_str.find_first_not_of(" \t");
        if (first != std::string::npos) {
            size_t last = fp_str.find_last_not_of(" \t");
            if (last != std::string::npos && last >= first) {
                fp_str = fp_str.substr(first, last - first + 1);
            }
        }
        
        std::cerr << "Debug: Parsing N=" << n_str << ", p=" << p_str << ", m=" << m_str << ", fp=" << fp_str << std::endl;
        
        result.N = std::stoi(n_str);
        result.p = std::stod(p_str);
        result.m = std::stod(m_str);
        result.friendship_probability = std::stod(fp_str);
        result.valid = true;
        
        std::cerr << "Debug: Successfully parsed last completed combination" << std::endl;
    } catch (const std::exception& e) {
        // Parsing failed
        std::cerr << "Debug: Parsing exception: " << e.what() << std::endl;
        return result;
    }
    
    return result;
}

bool is_combination_before_or_equal(int curr_N, double curr_m, double curr_p, double curr_fp,
                                     const LastCompleted& last_completed) {
    if (!last_completed.valid) {
        return false;
    }
    
    // Compare in iteration order: N, then m, then fp, then p
    if (curr_N < last_completed.N) {
        return true;
    }
    if (curr_N > last_completed.N) {
        return false;
    }
    
    if (curr_m < last_completed.m) {
        return true;
    }
    if (curr_m > last_completed.m) {
        return false;
    }
    
    if (curr_fp < last_completed.friendship_probability) {
        return true;
    }
    if (curr_fp > last_completed.friendship_probability) {
        return false;
    }
    
    if (curr_p <= last_completed.p) {
        return true;
    }
    return false;
}

struct PathComparisonResult {
    int N;
    double p;
    double m;
    double friendship_probability;
    double exactAveragePathLength;
    double approximateAveragePathLength;
    double error;
    size_t numEdges;
    double exactTime;
    double approximateTime;
    double timeRatio;
};

void create_comparison_sequential(const std::string& filepath, int N, double p, double m, double friendship_probability, int n_simulations) {
    std::cout << "Running " << n_simulations << " sequential simulations...\n";
    
    std::vector<PathComparisonResult> results;
    results.reserve(n_simulations);
    
    for (int i = 0; i < n_simulations; ++i) {
        std::cout << "Simulation " << (i + 1) << "/" << n_simulations << std::endl;
        
        // Create network
        auto network = generate_network(N, m, p, friendship_probability);
        
        // Convert to fast graph format
        auto fastGraph = convertToFastGraph(network);
        
        // Calculate both exact and approximate average path lengths with timing
        auto pathLengths = compareApproximateAndExactAveragePathLength(fastGraph);
        double exactLength = std::get<0>(pathLengths);
        double approximateLength = std::get<1>(pathLengths);
        double exactTime = std::get<2>(pathLengths);
        double approximateTime = std::get<3>(pathLengths);
        
        // Get number of edges
        size_t totalDegree = 0;
        for (const auto& neighbors : fastGraph) {
            totalDegree += neighbors.size();
        }
        size_t numEdges = totalDegree / 2;
        
        // Create result
        PathComparisonResult result;
        result.N = N;
        result.p = p;
        result.m = m;
        result.friendship_probability = friendship_probability;
        result.exactAveragePathLength = exactLength;
        result.approximateAveragePathLength = approximateLength;
        result.error = std::abs(exactLength - approximateLength) / exactLength; // Relative error
        result.numEdges = numEdges;
        result.exactTime = exactTime;
        result.approximateTime = approximateTime;
        result.timeRatio = exactTime / approximateTime; // Ratio of exact/approximate time
        
        results.push_back(result);
    }
    
    // Calculate statistics
    double avgExactLength = 0.0;
    double avgApproximateLength = 0.0;
    double avgError = 0.0;
    double maxError = 0.0;
    double minError = std::numeric_limits<double>::max();
    size_t avgNumEdges = 0;
    double avgExactTime = 0.0;
    double avgApproximateTime = 0.0;
    double avgTimeRatio = 0.0;
    
    for (const auto& result : results) {
        avgExactLength += result.exactAveragePathLength;
        avgApproximateLength += result.approximateAveragePathLength;
        avgError += result.error;
        maxError = std::max(maxError, result.error);
        minError = std::min(minError, result.error);
        avgNumEdges += result.numEdges;
        avgExactTime += result.exactTime;
        avgApproximateTime += result.approximateTime;
        avgTimeRatio += result.timeRatio;
    }
    
    avgExactLength /= n_simulations;
    avgApproximateLength /= n_simulations;
    avgError /= n_simulations;
    avgNumEdges /= n_simulations;
    avgExactTime /= n_simulations;
    avgApproximateTime /= n_simulations;
    avgTimeRatio /= n_simulations;
    
    // Print results
    std::cout << "\nResults for N=" << N << ", p=" << p << ", m=" << m 
              << ", friendship_probability=" << friendship_probability << ":\n";
    std::cout << "Average Number of Edges: " << avgNumEdges << "\n";
    std::cout << "Average Exact Path Length: " << avgExactLength << "\n";
    std::cout << "Average Approximate Path Length: " << avgApproximateLength << "\n";
    std::cout << "Average Relative Error: " << (avgError * 100) << "%\n";
    std::cout << "Min Relative Error: " << (minError * 100) << "%\n";
    std::cout << "Max Relative Error: " << (maxError * 100) << "%\n";
    std::cout << "Average Exact Time: " << avgExactTime << "s\n";
    std::cout << "Average Approximate Time: " << avgApproximateTime << "s\n";
    std::cout << "Average Time Ratio (exact/approximate): " << avgTimeRatio << "\n\n";
    
    // Save results to file
    std::ofstream file(filepath, std::ios::app);
    if (file.is_open()) {
        file << std::fixed << std::setprecision(8);
        file << N << ", " << p << ", " << m << ", " << friendship_probability << "\t\t\t"
             << avgExactLength << ", " << avgApproximateLength << "\t\t\t"
             << avgError << ", " << minError << ", " << maxError << ", " << avgNumEdges << "\t\t\t"
             << avgExactTime << ", " << avgApproximateTime << ", " << avgTimeRatio << "\n\n";
        file.close();
    } else {
        std::cerr << "Error opening file: " << filepath << std::endl;
    }
}

int main() {
    std::string output_file = "distances_200000.txt";
    LastCompleted last_completed = get_last_completed_combination(output_file);
    
    if (last_completed.valid) {
        std::cout << "Resuming from last completed combination: N=" << last_completed.N 
                  << ", m=" << last_completed.m 
                  << ", p=" << last_completed.p 
                  << ", fp=" << last_completed.friendship_probability << std::endl;
        std::cout << "Skipping already completed combinations..." << std::endl;
    } else {
        std::cout << "Starting from the beginning (no previous output found)" << std::endl;
    }

    for (int N: {200000}){
        for (int m: {2, 4, 5, 6, 8, 10}){
            for (double fp: {0.1, 0.3, 0.5, 0.7, 0.9}){
                for (double p: {0.1, 0.3, 0.5, 0.7, 0.9}){
                    if (is_combination_before_or_equal(N, m, p, fp, last_completed)) {
                        std::cout << "Skipping N=" << N << ", m=" << m 
                                  << ", p=" << p << ", fp=" << fp 
                                  << " (already completed)" << std::endl;
                        continue;
                    }
                    create_point_sequential(output_file, N, p, m, fp, 5);
                }
            }
        }
    }

    return 0;
}
